#!/usr/bin/env python3
"""
Vulnerability Database Manager
Author: SayerLinux
"""

import sqlite3
import json
import os
import requests
import time
import hashlib
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta


class VulnerabilityDatabase:
    """Centralized vulnerability database manager"""
    
    def __init__(self, db_path: str = "vulnerabilities.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialize the vulnerability database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Create CVE table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS cve (
                id TEXT PRIMARY KEY,
                description TEXT,
                severity TEXT,
                cvss_score REAL,
                cvss_vector TEXT,
                published_date TEXT,
                last_modified_date TEXT,
                references TEXT,
                affected_products TEXT,
                cwe_id TEXT,
                cwe_name TEXT,
                source TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Create exploit table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS exploits (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                cve_id TEXT,
                title TEXT,
                description TEXT,
                exploit_type TEXT,
                platform TEXT,
                author TEXT,
                date TEXT,
                url TEXT,
                poc TEXT,
                verified BOOLEAN DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (cve_id) REFERENCES cve(id)
            )
        ''')
        
        # Create signatures table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS signatures (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                type TEXT,
                pattern TEXT,
                severity TEXT,
                description TEXT,
                category TEXT,
                tags TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Create misconfigurations table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS misconfigurations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                type TEXT,
                description TEXT,
                severity TEXT,
                detection_method TEXT,
                remediation TEXT,
                references TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Create update_log table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS update_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source TEXT,
                update_type TEXT,
                items_added INTEGER,
                items_updated INTEGER,
                items_removed INTEGER,
                update_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                error_message TEXT
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def update_cve_database(self, force_update: bool = False) -> Dict[str, Any]:
        """Update CVE database from external sources"""
        update_result = {
            'success': False,
            'added': 0,
            'updated': 0,
            'errors': []
        }
        
        try:
            # Check last update
            if not force_update and self._should_update():
                update_result['message'] = "Database is up to date"
                return update_result
            
            # Update from NVD
            nvd_result = self._update_from_nvd()
            update_result['added'] += nvd_result['added']
            update_result['updated'] += nvd_result['updated']
            update_result['errors'].extend(nvd_result['errors'])
            
            # Update from exploit databases
            exploit_result = self._update_exploits()
            update_result['added'] += exploit_result['added']
            update_result['updated'] += exploit_result['updated']
            update_result['errors'].extend(exploit_result['errors'])
            
            # Update signatures
            signature_result = self._update_signatures()
            update_result['added'] += signature_result['added']
            update_result['updated'] += signature_result['updated']
            update_result['errors'].extend(signature_result['errors'])
            
            # Update misconfigurations
            misconfig_result = self._update_misconfigurations()
            update_result['added'] += misconfig_result['added']
            update_result['updated'] += misconfig_result['updated']
            update_result['errors'].extend(misconfig_result['errors'])
            
            update_result['success'] = True
            
            # Log update
            self._log_update('all', update_result['added'], update_result['updated'], 0, 
                           '; '.join(update_result['errors']) if update_result['errors'] else None)
            
        except Exception as e:
            update_result['errors'].append(str(e))
            self._log_update('all', 0, 0, 0, str(e))
        
        return update_result
    
    def _should_update(self) -> bool:
        """Check if database should be updated"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT MAX(update_date) FROM update_log 
            WHERE update_type = 'cve' AND update_date > datetime('now', '-1 day')
        ''')
        
        last_update = cursor.fetchone()[0]
        conn.close()
        
        return last_update is None
    
    def _update_from_nvd(self) -> Dict[str, Any]:
        """Update CVE data from NIST NVD"""
        result = {'added': 0, 'updated': 0, 'errors': []}
        
        try:
            # Get recent CVEs from NVD API
            current_year = datetime.now().year
            
            for year in range(current_year - 2, current_year + 1):
                url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?pubStartDate={(datetime.now() - timedelta(days=30)).isoformat()}&pubEndDate={datetime.now().isoformat()}"
                
                response = requests.get(url, timeout=30)
                if response.status_code == 200:
                    data = response.json()
                    
                    for vuln in data.get('vulnerabilities', []):
                        cve_data = vuln.get('cve', {})
                        
                        cve_info = {
                            'id': cve_data.get('id'),
                            'description': cve_data.get('descriptions', [{}])[0].get('value', ''),
                            'published_date': cve_data.get('published'),
                            'last_modified_date': cve_data.get('lastModified'),
                            'references': json.dumps([ref.get('url', '') for ref in cve_data.get('references', [])]),
                            'source': 'NVD'
                        }
                        
                        # Get CVSS metrics
                        metrics = cve_data.get('metrics', {})
                        cvss_data = metrics.get('cvssMetricV31', [{}])[0].get('cvssData', {})
                        
                        cve_info.update({
                            'severity': cvss_data.get('baseSeverity', 'UNKNOWN'),
                            'cvss_score': cvss_data.get('baseScore', 0.0),
                            'cvss_vector': cvss_data.get('vectorString', ''),
                            'cwe_id': cvss_data.get('cweId', ''),
                            'cwe_name': ''
                        })
                        
                        # Get affected products
                        affected = []
                        for node in cve_data.get('configurations', [{}])[0].get('nodes', []):
                            for cpe_match in node.get('cpeMatch', []):
                                if cpe_match.get('criteria'):
                                    affected.append(cpe_match['criteria'])
                        
                        cve_info['affected_products'] = json.dumps(affected)
                        
                        # Insert or update CVE
                        self._insert_or_update_cve(cve_info)
                        result['added'] += 1
                
                time.sleep(1)  # Rate limiting
        
        except Exception as e:
            result['errors'].append(f"NVD update error: {str(e)}")
        
        return result
    
    def _update_exploits(self) -> Dict[str, Any]:
        """Update exploit data from various sources"""
        result = {'added': 0, 'updated': 0, 'errors': []}
        
        try:
            # ExploitDB integration
            exploitdb_result = self._update_from_exploitdb()
            result['added'] += exploitdb_result['added']
            result['updated'] += exploitdb_result['updated']
            result['errors'].extend(exploitdb_result['errors'])
            
            # Metasploit integration
            metasploit_result = self._update_from_metasploit()
            result['added'] += metasploit_result['added']
            result['updated'] += metasploit_result['updated']
            result['errors'].extend(metasploit_result['errors'])
            
        except Exception as e:
            result['errors'].append(f"Exploit update error: {str(e)}")
        
        return result
    
    def _update_from_exploitdb(self) -> Dict[str, Any]:
        """Update from ExploitDB"""
        result = {'added': 0, 'updated': 0, 'errors': []}
        
        try:
            # Use local exploit database or API
            exploitdb_url = "https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_exploits.csv"
            
            response = requests.get(exploitdb_url, timeout=30)
            if response.status_code == 200:
                # Parse CSV data (simplified)
                lines = response.text.split('\n')[1:]  # Skip header
                
                for line in lines[:100]:  # Limit for demo
                    if line.strip():
                        parts = line.split(',')
                        if len(parts) >= 6:
                            exploit = {
                                'cve_id': parts[1] if len(parts) > 1 and parts[1].startswith('CVE-') else None,
                                'title': parts[2] if len(parts) > 2 else '',
                                'description': '',
                                'exploit_type': parts[5] if len(parts) > 5 else '',
                                'platform': parts[4] if len(parts) > 4 else '',
                                'author': '',
                                'date': parts[3] if len(parts) > 3 else '',
                                'url': f"https://www.exploit-db.com/exploits/{parts[0]}" if len(parts) > 0 else '',
                                'poc': '',
                                'verified': False
                            }
                            
                            self._insert_exploit(exploit)
                            result['added'] += 1
        
        except Exception as e:
            result['errors'].append(f"ExploitDB update error: {str(e)}")
        
        return result
    
    def _update_from_metasploit(self) -> Dict[str, Any]:
        """Update from Metasploit modules"""
        result = {'added': 0, 'updated': 0, 'errors': []}
        
        try:
            # This would typically integrate with Metasploit RPC or local modules
            # For now, add some common Metasploit modules
            metasploit_modules = [
                {
                    'cve_id': 'CVE-2021-44228',
                    'title': 'Apache Log4j2 JNDI RCE',
                    'description': 'Log4j2 vulnerable to remote code execution',
                    'exploit_type': 'RCE',
                    'platform': 'Java',
                    'author': 'Metasploit Team',
                    'date': '2021-12-10',
                    'url': 'https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/multi/http/log4j_header_injection.rb',
                    'poc': '',
                    'verified': True
                },
                {
                    'cve_id': 'CVE-2021-34527',
                    'title': 'Windows Print Spooler Elevation of Privilege',
                    'description': 'Windows Print Spooler privilege escalation',
                    'exploit_type': 'PRIVILEGE_ESCALATION',
                    'platform': 'Windows',
                    'author': 'Metasploit Team',
                    'date': '2021-07-01',
                    'url': 'https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/dcerpc/cve_2021_34527_printnightmare.rb',
                    'poc': '',
                    'verified': True
                }
            ]
            
            for module in metasploit_modules:
                self._insert_exploit(module)
                result['added'] += 1
        
        except Exception as e:
            result['errors'].append(f"Metasploit update error: {str(e)}")
        
        return result
    
    def _update_signatures(self) -> Dict[str, Any]:
        """Update vulnerability signatures"""
        result = {'added': 0, 'updated': 0, 'errors': []}
        
        try:
            signatures = [
                {
                    'name': 'SQL Injection Pattern',
                    'type': 'SQL_INJECTION',
                    'pattern': r'(union|select|insert|update|delete|drop|alter|create)\s+(select|from|where|table|database)',
                    'severity': 'high',
                    'description': 'SQL injection attempt detected',
                    'category': 'injection',
                    'tags': 'sql,injection,database'
                },
                {
                    'name': 'XSS Pattern',
                    'type': 'XSS',
                    'pattern': r'<script[^>]*>.*?</script>|<iframe[^>]*>.*?</iframe>|<object[^>]*>.*?</object>',
                    'severity': 'medium',
                    'description': 'Cross-site scripting attempt detected',
                    'category': 'xss',
                    'tags': 'xss,cross-site,scripting'
                },
                {
                    'name': 'LFI Pattern',
                    'type': 'LFI',
                    'pattern': r'\.\./|\.\.\\|/etc/passwd|/windows/system32|/proc/',
                    'severity': 'high',
                    'description': 'Local file inclusion attempt detected',
                    'category': 'file_inclusion',
                    'tags': 'lfi,file,inclusion'
                },
                {
                    'name': 'RCE Pattern',
                    'type': 'RCE',
                    'pattern': r'(system|exec|shell_exec|passthru|proc_open|popen|eval|assert)\s*\(',
                    'severity': 'critical',
                    'description': 'Remote code execution attempt detected',
                    'category': 'rce',
                    'tags': 'rce,code,execution'
                }
            ]
            
            for signature in signatures:
                self._insert_signature(signature)
                result['added'] += 1
        
        except Exception as e:
            result['errors'].append(f"Signature update error: {str(e)}")
        
        return result
    
    def _update_misconfigurations(self) -> Dict[str, Any]:
        """Update misconfiguration data"""
        result = {'added': 0, 'updated': 0, 'errors': []}
        
        try:
            misconfigs = [
                {
                    'name': 'Directory Listing Enabled',
                    'type': 'DIRECTORY_LISTING',
                    'description': 'Directory listing is enabled on web server',
                    'severity': 'medium',
                    'detection_method': 'Check for Index of/ in response',
                    'remediation': 'Disable directory listing in web server configuration',
                    'references': 'https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/02-Test_for_Default_Credentials'
                },
                {
                    'name': 'Missing Security Headers',
                    'type': 'MISSING_HEADERS',
                    'description': 'Security headers are not properly configured',
                    'severity': 'low',
                    'detection_method': 'Check for missing security headers',
                    'remediation': 'Add security headers like X-Content-Type-Options, X-Frame-Options, etc.',
                    'references': 'https://owasp.org/www-project-secure-headers/'
                },
                {
                    'name': 'Default Files Present',
                    'type': 'DEFAULT_FILES',
                    'description': 'Default installation files are present',
                    'severity': 'low',
                    'detection_method': 'Check for default installation files',
                    'remediation': 'Remove default installation files',
                    'references': 'https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/01-Test_Network_Infrastructure_Configuration'
                }
            ]
            
            for misconfig in misconfigs:
                self._insert_misconfiguration(misconfig)
                result['added'] += 1
        
        except Exception as e:
            result['errors'].append(f"Misconfiguration update error: {str(e)}")
        
        return result
    
    def _insert_or_update_cve(self, cve_info: Dict[str, Any]):
        """Insert or update CVE in database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO cve 
            (id, description, severity, cvss_score, cvss_vector, published_date, 
             last_modified_date, references, affected_products, cwe_id, cwe_name, source)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            cve_info['id'],
            cve_info['description'],
            cve_info['severity'],
            cve_info['cvss_score'],
            cve_info['cvss_vector'],
            cve_info['published_date'],
            cve_info['last_modified_date'],
            cve_info['references'],
            cve_info['affected_products'],
            cve_info['cwe_id'],
            cve_info['cwe_name'],
            cve_info['source']
        ))
        
        conn.commit()
        conn.close()
    
    def _insert_exploit(self, exploit: Dict[str, Any]):
        """Insert exploit into database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR IGNORE INTO exploits 
            (cve_id, title, description, exploit_type, platform, author, date, url, poc, verified)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            exploit['cve_id'],
            exploit['title'],
            exploit['description'],
            exploit['exploit_type'],
            exploit['platform'],
            exploit['author'],
            exploit['date'],
            exploit['url'],
            exploit['poc'],
            exploit['verified']
        ))
        
        conn.commit()
        conn.close()
    
    def _insert_signature(self, signature: Dict[str, Any]):
        """Insert signature into database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR IGNORE INTO signatures 
            (name, type, pattern, severity, description, category, tags)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (
            signature['name'],
            signature['type'],
            signature['pattern'],
            signature['severity'],
            signature['description'],
            signature['category'],
            signature['tags']
        ))
        
        conn.commit()
        conn.close()
    
    def _insert_misconfiguration(self, misconfig: Dict[str, Any]):
        """Insert misconfiguration into database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR IGNORE INTO misconfigurations 
            (name, type, description, severity, detection_method, remediation, references)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (
            misconfig['name'],
            misconfig['type'],
            misconfig['description'],
            misconfig['severity'],
            misconfig['detection_method'],
            misconfig['remediation'],
            misconfig['references']
        ))
        
        conn.commit()
        conn.close()
    
    def _log_update(self, source: str, added: int, updated: int, removed: int, error: str = None):
        """Log database update"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO update_log (source, update_type, items_added, items_updated, items_removed, error_message)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (source, 'cve', added, updated, removed, error))
        
        conn.commit()
        conn.close()
    
    def search_vulnerabilities(self, query: str, limit: int = 50) -> List[Dict[str, Any]]:
        """Search vulnerabilities by query"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT * FROM cve 
            WHERE id LIKE ? OR description LIKE ? OR affected_products LIKE ?
            ORDER BY cvss_score DESC, published_date DESC
            LIMIT ?
        ''', (f'%{query}%', f'%{query}%', f'%{query}%', limit))
        
        columns = [description[0] for description in cursor.description]
        results = []
        
        for row in cursor.fetchall():
            result = dict(zip(columns, row))
            result['references'] = json.loads(result['references']) if result['references'] else []
            result['affected_products'] = json.loads(result['affected_products']) if result['affected_products'] else []
            results.append(result)
        
        conn.close()
        return results
    
    def get_vulnerability_by_id(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """Get vulnerability by CVE ID"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM cve WHERE id = ?', (cve_id,))
        row = cursor.fetchone()
        
        if row:
            columns = [description[0] for description in cursor.description]
            result = dict(zip(columns, row))
            result['references'] = json.loads(result['references']) if result['references'] else []
            result['affected_products'] = json.loads(result['affected_products']) if result['affected_products'] else []
            
            # Get related exploits
            cursor.execute('SELECT * FROM exploits WHERE cve_id = ?', (cve_id,))
            exploit_columns = [description[0] for description in cursor.description]
            result['exploits'] = [dict(zip(exploit_columns, exploit_row)) for exploit_row in cursor.fetchall()]
            
            conn.close()
            return result
        
        conn.close()
        return None
    
    def get_signatures(self, signature_type: str = None) -> List[Dict[str, Any]]:
        """Get vulnerability signatures"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        if signature_type:
            cursor.execute('SELECT * FROM signatures WHERE type = ?', (signature_type,))
        else:
            cursor.execute('SELECT * FROM signatures')
        
        columns = [description[0] for description in cursor.description]
        results = [dict(zip(columns, row)) for row in cursor.fetchall()]
        
        conn.close()
        return results
    
    def get_misconfigurations(self, misconfig_type: str = None) -> List[Dict[str, Any]]:
        """Get misconfigurations"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        if misconfig_type:
            cursor.execute('SELECT * FROM misconfigurations WHERE type = ?', (misconfig_type,))
        else:
            cursor.execute('SELECT * FROM misconfigurations')
        
        columns = [description[0] for description in cursor.description]
        results = [dict(zip(columns, row)) for row in cursor.fetchall()]
        
        conn.close()
        return results
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get database statistics"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        stats = {}
        
        # CVE statistics
        cursor.execute('SELECT COUNT(*) FROM cve')
        stats['total_cves'] = cursor.fetchone()[0]
        
        cursor.execute('SELECT severity, COUNT(*) FROM cve GROUP BY severity')
        stats['severity_distribution'] = dict(cursor.fetchall())
        
        # Exploit statistics
        cursor.execute('SELECT COUNT(*) FROM exploits')
        stats['total_exploits'] = cursor.fetchone()[0]
        
        cursor.execute('SELECT COUNT(*) FROM exploits WHERE verified = 1')
        stats['verified_exploits'] = cursor.fetchone()[0]
        
        # Signature statistics
        cursor.execute('SELECT COUNT(*) FROM signatures')
        stats['total_signatures'] = cursor.fetchone()[0]
        
        cursor.execute('SELECT type, COUNT(*) FROM signatures GROUP BY type')
        stats['signature_types'] = dict(cursor.fetchall())
        
        # Misconfiguration statistics
        cursor.execute('SELECT COUNT(*) FROM misconfigurations')
        stats['total_misconfigurations'] = cursor.fetchone()[0]
        
        # Last update
        cursor.execute('SELECT MAX(update_date) FROM update_log')
        last_update = cursor.fetchone()[0]
        stats['last_update'] = last_update
        
        conn.close()
        return stats
    
    def export_database(self, format_type: str = 'json', output_file: str = None) -> str:
        """Export database to different formats"""
        if not output_file:
            output_file = f"vulnerabilities_export.{format_type}"
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Get all data
        cursor.execute('SELECT * FROM cve')
        cve_columns = [description[0] for description in cursor.description]
        cves = [dict(zip(cve_columns, row)) for row in cursor.fetchall()]
        
        cursor.execute('SELECT * FROM exploits')
        exploit_columns = [description[0] for description in cursor.description]
        exploits = [dict(zip(exploit_columns, row)) for row in cursor.fetchall()]
        
        cursor.execute('SELECT * FROM signatures')
        signature_columns = [description[0] for description in cursor.description]
        signatures = [dict(zip(signature_columns, row)) for row in cursor.fetchall()]
        
        cursor.execute('SELECT * FROM misconfigurations')
        misconfig_columns = [description[0] for description in cursor.description]
        misconfigs = [dict(zip(misconfig_columns, row)) for row in cursor.fetchall()]
        
        conn.close()
        
        data = {
            'cves': cves,
            'exploits': exploits,
            'signatures': signatures,
            'misconfigurations': misconfigs,
            'export_date': datetime.now().isoformat()
        }
        
        if format_type.lower() == 'json':
            with open(output_file, 'w') as f:
                json.dump(data, f, indent=2, default=str)
        elif format_type.lower() == 'csv':
            import csv
            # Export CVEs as CSV
            with open(f"cves_{output_file}", 'w', newline='') as f:
                if cves:
                    writer = csv.DictWriter(f, fieldnames=cve_columns)
                    writer.writeheader()
                    writer.writerows(cves)
        
        return output_file
    
    def get_update_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get database update history"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT * FROM update_log 
            ORDER BY update_date DESC 
            LIMIT ?
        ''', (limit,))
        
        columns = [description[0] for description in cursor.description]
        results = [dict(zip(columns, row)) for row in cursor.fetchall()]
        
        conn.close()
        return results